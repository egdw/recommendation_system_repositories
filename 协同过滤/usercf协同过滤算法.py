# -*- coding: utf-8 -*-
"""userCF协同过滤算法.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ibhC0M-XImZwCxRmeT9bBl3O7wUzgJVW
"""

# 手动实现协同过滤算法
import numpy as np
import matplotlib.pyplot as plt
import math

# @date 2020-11-26
# user-item matrix
users = ['小明','小花','小美','小张','小李']
movies = ['电影1','电影2','电影3','电影4','电影5','电影6','电影7']

# 模拟的user-item矩阵
user_item_matrix = np.array([
  [3,1,4,4,1,0,0],
  [0,5,1,0,0,4,0],
  [1,0,5,4,3,5,2],
  [3,1,4,3,5,0,0],
  [5,3,0,1,0,5,5]
])

user_item_matrix

"""https://blog.csdn.net/fycghy0803/article/details/79880452"""

# 定义各类常见的相似度

# 定义余弦相似度
def cosine_index(x,y):
  return np.sum(x * y)/(math.sqrt(np.sum(x**2)) * math.sqrt(np.sum(y**2)))

# 欧式距离相似度
def euclidean_index(x,y):
  return math.sqrt(np.sum((x-y)**2))

# 杰卡德相似度
def jaccard_index(x,y):
  
  pass

cosine_index(user_item_matrix[0],user_item_matrix[2]) #测试余弦相似度

euclidean_index(user_item_matrix[0],user_item_matrix[2]) # 测试欧式距离相似度

# 计算相似度矩阵
# 计算出的矩阵是一个对称矩阵
similary_matrix = np.zeros(shape=(len(user_item_matrix),len(user_item_matrix)))
for i in range(len(user_item_matrix)):
  for j in range(i,len(user_item_matrix)):
    if(i!=j):
      # 用欧式距离计算相似度
      # val = euclidean_index(user_item_matrix[i],user_item_matrix[j])
      # 用cosine计算相似度
      val = cosine_index(user_item_matrix[i],user_item_matrix[j])
      # 由于是对称矩阵，只计算其中一半就可以了，另外一半填充就行
      similary_matrix[i][j] = val
      similary_matrix[j][i] = val

similary_matrix # 获得相似矩阵

# 然后可以根据你输入的用户，进行动态的计算当前与你相似度最高的用户是谁
# 用户1 和 谁的相似度最高
# 可以看出用户四的的相似度是最高的
np.argmax(similary_matrix[0])

np.argsort(-similary_matrix[0]) #从大到小排序相似度最高的用户

# user_items 代表用户-物品矩阵 user_index 代表需要给哪个user推荐，K代表临近的用户 C表示最大的推荐的数量
def recommend(user_item,user_index,K = 3,C = 10):
  neibor_user = np.argsort(-similary_matrix[user_index])[0:K]
  items = set()
  for i in range(len(neibor_user)):
    if(len(items) >= C):
        break
    for j in range(len(user_item[0])):
      if(len(items) >= C):
        break
      if user_item[user_index][j] == 0 and user_item[i][j]!=0:
        items.add(j)

  return items

# 用户展示显示出效果
def desp(users,movies,user_index,movies_list):
  print("给用户（%s）的推荐电影分别是："%(users[user_index]))
  result = ""
  for i in movies_list:
    result = result + movies[i]
    result = result + " "
  print(result)

# 查找出用户1和用户3中，用户1没有的，但是用户三有的物品从而推荐给用户
user_item_matrix[0]-user_item_matrix[3]

recommend_list = recommend(user_item_matrix,3,C=10)
print(recommend_list)
desp(users,movies,3,recommend_list)



