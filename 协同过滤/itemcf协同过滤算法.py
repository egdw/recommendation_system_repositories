# -*- coding: utf-8 -*-
"""ItemCF协同过滤算法.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/10MZsH1MC8N1Azx-ZAxD1GjN1vIPqrwi4
"""

# 手动实现协同过滤算法
import numpy as np
import matplotlib.pyplot as plt
import math

# @date 2020-11-26
# item-item matrix
# item和user的区别主要是，item是一列和一列进行相比，而user是一行一行进行相比的。
users = ['小明','小花','小美','小张','小李','小方']
movies = ['电影1','电影2','电影3','电影4','电影5','电影6','电影7']

# 模拟的user-item矩阵
# user_item_matrix = np.array([
#   [3,1,4,4,1,0,0],
#   [0,5,1,0,0,4,0],
#   [1,0,5,4,3,5,2],
#   [3,1,4,3,5,0,0],
#   [5,3,0,1,0,5,5]
# ])
user_item_matrix = np.array([
  [4,3,0,0,5,0],
  [5,0,4,0,4,0],
  [4,0,5,3,4,0],
  [0,3,0,0,0,5],
  [0,4,0,0,0,4],
  [0,0,2,4,0,5]
])

user_item_matrix

user_item_matrix[:,1].shape

"""https://blog.csdn.net/fycghy0803/article/details/79880452"""

# 定义各类常见的相似度

# 定义余弦相似度
def cosine_index(x,y):
  return np.sum(x * y)/(math.sqrt(np.sum(x**2)) * math.sqrt(np.sum(y**2)))

# 欧式距离相似度
def euclidean_index(x,y):
  return math.sqrt(np.sum((x-y)**2))

# 杰卡德相似度
def jaccard_index(x,y):
  
  pass

cosine_index(user_item_matrix[0],user_item_matrix[2]) #测试余弦相似度

euclidean_index(user_item_matrix[0],user_item_matrix[2]) # 测试欧式距离相似度

# 计算相似度矩阵
# 计算出的矩阵是一个对称矩阵
similary_matrix = np.zeros(shape=(len(user_item_matrix[0]),len(user_item_matrix[0])))
for i in range(len(user_item_matrix[0])):
  for j in range(i,len(user_item_matrix[0])):
    if(i!=j):
      # 用欧式距离计算相似度
      # val = euclidean_index(user_item_matrix[i],user_item_matrix[j])
      # 用cosine计算相似度
      val = cosine_index(user_item_matrix[:,i],user_item_matrix[:,j])
      # 由于是对称矩阵，只计算其中一半就可以了，另外一半填充就行
      similary_matrix[i][j] = val
      similary_matrix[j][i] = val

similary_matrix # 获得相似矩阵

# 然后可以根据你输入的用户，进行动态的计算当前与你相似度最高的用户是谁
# 用户1 和 谁的相似度最高
# 可以看出用户四的的相似度是最高的
np.argmax(similary_matrix[0])

np.argsort(-similary_matrix[0]) #从大到小排序相似度最高的物品

# user_items 代表用户-物品矩阵 item_index 代表需要给哪个item推荐，K代表临近的物品 C表示最大的推荐的物品数量
def recommend(user_item,item_index,K = 3,C = 10):
  neibor_item = np.argsort(-similary_matrix[item_index])[0:K]
  items = neibor_item
  return items

# 用户展示显示出效果
def desp(users,movies,user_index,movies_list):
  print("给用户（%s）的推荐电影分别是："%(movies[user_index]))
  result = ""
  for i in movies_list:
    result = result + movies[i]
    result = result + " "
  print(result)

# 第一方案 用户点击了物品1，因此根据相似度把相关的物品推荐给用户
recommend_list = recommend(user_item_matrix,1,C=10)
print(recommend_list)
desp(users,movies,3,recommend_list)

# 第二方案，根据用户当前的喜好的物品 * 物品的相似度 进行物品的推荐
# 比如我这里选择任意的一个物品
# 对用户一的第一个物品进行推荐
def recommend2(user_index,item_index):
  print(user_item_matrix[user_index])
  temp = user_item_matrix[user_index]
  similarys = user_item_matrix[user_index][item_index] * similary_matrix[item_index]
  for index,i in enumerate(temp):
    if i == 0:
      temp[index] = similarys[index]
  print(temp)
  return np.argsort(-temp)

# recommend2(0,0)

desp(users,movies,0,recommend2(0,0))

